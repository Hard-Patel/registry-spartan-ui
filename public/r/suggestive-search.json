{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "suggestive-search",
  "type": "registry:component",
  "title": "Suggestive Search",
  "description": "Search component with animated suggestions and effects",
  "dependencies": [
    "motion",
    "tailwind-merge",
    "clsx",
    "lucide-react"
  ],
  "files": [
    {
      "path": "registry/new-york/ui/SuggestiveSearch.tsx",
      "content": "// SuggestiveSearch.tsx\nimport { cn } from \"@/lib/utils\";\nimport { Search } from \"lucide-react\";\nimport { motion } from \"motion/react\";\nimport React, {\n  ReactElement,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n  type RefObject,\n} from \"react\";\n\n/**\n * Props for any effect renderer. Effects are responsible for animating the\n * provided `text` and invoking the lifecycle callbacks when phases complete.\n */\nexport interface EffectRendererProps {\n  text: string;\n  isActive: boolean;\n  allowDelete?: boolean; // new: indicates if effect should delete/advance\n  typeDurationMs: number;\n  deleteDurationMs: number;\n  pauseAfterTypeMs: number;\n  prefersReducedMotion?: boolean;\n  /** Called by the effect when it finishes the delete/exit phase and ready for next suggestion */\n  onDeleteComplete?: () => void;\n  /** Optional container ref if the effect needs to measure or align itself */\n  containerRef?: RefObject<HTMLElement | null>;\n}\n\n/** Convenience union for built-in effects */\nexport type BuiltinEffect = \"typewriter\" | \"slide\" | \"fade\" | \"none\";\n\n/** Props of the main SuggestiveSearch component */\nexport interface SuggestiveSearchProps {\n  onChange?: (val: string) => void;\n  suggestions?: string[];\n  className?: string;\n  Leading?: () => ReactElement;\n  /** show/hide leading icon */\n  showLeading?: boolean;\n  /** trailing icon component */\n  Trailing?: () => ReactElement;\n  /** show/hide trailing icon */\n  showTrailing?: boolean;\n  /** convenience selection of built-in effects */\n  effect?: BuiltinEffect;\n  /** override with a custom Effect component */\n  EffectComponent?: React.ComponentType<EffectRendererProps>;\n  typeDurationMs?: number;\n  deleteDurationMs?: number;\n  pauseAfterTypeMs?: number;\n  /** play suggestions forever or only once */\n  animateMode?: \"infinite\" | \"once\";\n}\n\n/* ---------------------------\n   TypewriterEffect\n   - Reveal mask width 0->100% for typing (duration controlled)\n   - Hold, then shrink for deleting (if allowed)\n   - Shows blinking cursor while typing/paused\n   ----------------------------*/\nexport const TypewriterEffect: React.FC<EffectRendererProps> = ({\n  text,\n  isActive,\n  allowDelete = true,\n  typeDurationMs,\n  deleteDurationMs,\n  pauseAfterTypeMs,\n  prefersReducedMotion,\n  onDeleteComplete,\n  containerRef,\n}) => {\n  const [phase, setPhase] = useState<\"typing\" | \"paused\" | \"deleting\">(\n    \"typing\"\n  );\n  const timers = useRef<number[]>([]);\n\n  useEffect(() => {\n    setPhase(\"typing\");\n    timers.current.forEach(clearTimeout);\n    timers.current = [];\n    return () => {\n      timers.current.forEach(clearTimeout);\n      timers.current = [];\n    };\n  }, [text, isActive, allowDelete]);\n\n  useEffect(() => {\n    if (!isActive) {\n      setPhase(\"typing\");\n      timers.current.forEach(clearTimeout);\n      timers.current = [];\n    }\n  }, [isActive]);\n\n  useEffect(() => {\n    if (!isActive) return;\n    if (prefersReducedMotion) {\n      if (!allowDelete) return;\n      const t = window.setTimeout(\n        () => onDeleteComplete?.(),\n        Math.max(200, pauseAfterTypeMs)\n      );\n      timers.current.push(t);\n      return () => timers.current.forEach(clearTimeout);\n    }\n  }, [\n    isActive,\n    prefersReducedMotion,\n    allowDelete,\n    pauseAfterTypeMs,\n    onDeleteComplete,\n  ]);\n\n  if (!isActive) return null;\n\n  return (\n    <div\n      ref={containerRef as RefObject<HTMLDivElement> | undefined}\n      style={{\n        display: \"inline-block\",\n        overflow: \"hidden\",\n        whiteSpace: \"nowrap\",\n        alignItems: \"center\",\n      }}\n    >\n      {prefersReducedMotion ? (\n        <span className=\"text-sm text-muted-foreground select-none\">\n          {text}\n        </span>\n      ) : (\n        <motion.div\n          key={text}\n          initial={{ width: \"0%\" }}\n          animate={\n            phase === \"typing\"\n              ? { width: \"100%\" }\n              : phase === \"deleting\"\n              ? { width: \"0%\" }\n              : { width: \"100%\" }\n          }\n          transition={\n            phase === \"typing\"\n              ? { duration: typeDurationMs / 1000, ease: \"linear\" }\n              : phase === \"deleting\"\n              ? { duration: deleteDurationMs / 1000, ease: \"linear\" }\n              : {}\n          }\n          onAnimationComplete={() => {\n            if (phase === \"typing\") {\n              setPhase(\"paused\");\n              if (allowDelete) {\n                const t = window.setTimeout(\n                  () => setPhase(\"deleting\"),\n                  pauseAfterTypeMs\n                );\n                timers.current.push(t);\n              }\n            } else if (phase === \"deleting\") {\n              onDeleteComplete?.();\n            }\n          }}\n          style={{\n            display: \"inline-flex\",\n            alignItems: \"center\",\n            overflow: \"hidden\",\n            whiteSpace: \"nowrap\",\n          }}\n        >\n          <span className=\"text-sm text-muted-foreground select-none\">\n            {text}\n          </span>\n\n          {/* blinking cursor */}\n          <motion.span\n            aria-hidden\n            style={{\n              display: \"inline-block\",\n              width: 1,\n              marginLeft: 4,\n              height: \"1.1em\",\n              verticalAlign: \"middle\",\n            }}\n            className=\"bg-muted-foreground\"\n            animate={\n              phase === \"typing\" || phase === \"paused\"\n                ? { opacity: [0, 1, 0] }\n                : { opacity: 0 }\n            }\n            transition={\n              phase === \"typing\" || phase === \"paused\"\n                ? { repeat: Infinity, duration: 0.9, ease: \"linear\" }\n                : { duration: 0.1 }\n            }\n          />\n        </motion.div>\n      )}\n    </div>\n  );\n};\n\n/* ---------------------------\n   SlideEffect\n   - Slide text from top -> center -> bottom\n   - Uses transforms; good for a 'carousel' style\n   ----------------------------*/\nexport const SlideEffect: React.FC<EffectRendererProps> = ({\n  text,\n  isActive,\n  allowDelete = true,\n  typeDurationMs,\n  deleteDurationMs,\n  pauseAfterTypeMs,\n  prefersReducedMotion,\n  onDeleteComplete,\n  containerRef,\n}) => {\n  const [phase, setPhase] = useState<\"enter\" | \"pause\" | \"exit\">(\"enter\");\n  const timers = useRef<number[]>([]);\n\n  useEffect(() => {\n    setPhase(\"enter\");\n    timers.current.forEach(clearTimeout);\n    timers.current = [];\n    return () => {\n      timers.current.forEach(clearTimeout);\n      timers.current = [];\n    };\n  }, [text, isActive, allowDelete]);\n\n  useEffect(() => {\n    if (!isActive) {\n      setPhase(\"enter\");\n      timers.current.forEach(clearTimeout);\n      timers.current = [];\n    }\n  }, [isActive]);\n\n  if (!isActive) return null;\n\n  if (prefersReducedMotion) {\n    useEffect(() => {\n      if (!allowDelete) return;\n      const t = window.setTimeout(\n        () => onDeleteComplete?.(),\n        Math.max(200, pauseAfterTypeMs)\n      );\n      timers.current.push(t);\n      return () => timers.current.forEach(clearTimeout);\n    }, [onDeleteComplete, pauseAfterTypeMs, allowDelete]);\n    return (\n      <span className=\"text-sm text-muted-foreground select-none\">{text}</span>\n    );\n  }\n\n  return (\n    <div\n      ref={containerRef as RefObject<HTMLDivElement> | undefined}\n      style={{\n        overflow: \"hidden\",\n        display: \"inline-block\",\n        whiteSpace: \"nowrap\",\n        alignItems: \"center\",\n      }}\n    >\n      <motion.div\n        key={text}\n        initial={{ y: \"-100%\" }}\n        animate={\n          phase === \"enter\"\n            ? { y: \"0%\" }\n            : phase === \"exit\"\n            ? { y: \"100%\" }\n            : { y: \"0%\" }\n        }\n        transition={\n          phase === \"enter\"\n            ? { duration: typeDurationMs / 1000, ease: \"easeOut\" }\n            : { duration: deleteDurationMs / 1000, ease: \"easeIn\" }\n        }\n        onAnimationComplete={() => {\n          if (phase === \"enter\") {\n            setPhase(\"pause\");\n            if (allowDelete) {\n              const t = window.setTimeout(\n                () => setPhase(\"exit\"),\n                pauseAfterTypeMs\n              );\n              timers.current.push(t);\n            }\n          } else if (phase === \"exit\") {\n            onDeleteComplete?.();\n          }\n        }}\n        style={{ display: \"inline-block\" }}\n      >\n        <span className=\"text-sm text-muted-foreground select-none\">\n          {text}\n        </span>\n      </motion.div>\n    </div>\n  );\n};\n\n/* ---------------------------\n   FadeEffect\n   - Crossfade opacity in/out (new)\n   ----------------------------*/\nexport const FadeEffect: React.FC<EffectRendererProps> = ({\n  text,\n  isActive,\n  allowDelete = true,\n  typeDurationMs,\n  deleteDurationMs,\n  pauseAfterTypeMs,\n  prefersReducedMotion,\n  onDeleteComplete,\n  containerRef,\n}) => {\n  const [phase, setPhase] = useState<\"fadeIn\" | \"hold\" | \"fadeOut\">(\"fadeIn\");\n  const timers = useRef<number[]>([]);\n\n  useEffect(() => {\n    setPhase(\"fadeIn\");\n    timers.current.forEach(clearTimeout);\n    timers.current = [];\n    return () => {\n      timers.current.forEach(clearTimeout);\n      timers.current = [];\n    };\n  }, [text, isActive, allowDelete]);\n\n  useEffect(() => {\n    if (!isActive) {\n      setPhase(\"fadeIn\");\n      timers.current.forEach(clearTimeout);\n      timers.current = [];\n    }\n  }, [isActive]);\n\n  if (!isActive) return null;\n\n  if (prefersReducedMotion) {\n    useEffect(() => {\n      if (!allowDelete) return;\n      const t = window.setTimeout(\n        () => onDeleteComplete?.(),\n        Math.max(200, pauseAfterTypeMs)\n      );\n      timers.current.push(t);\n      return () => timers.current.forEach(clearTimeout);\n    }, [onDeleteComplete, pauseAfterTypeMs, allowDelete]);\n    return (\n      <span className=\"text-sm text-muted-foreground select-none\">{text}</span>\n    );\n  }\n\n  return (\n    <div\n      ref={containerRef as RefObject<HTMLDivElement> | undefined}\n      style={{\n        overflow: \"hidden\",\n        display: \"inline-block\",\n        whiteSpace: \"nowrap\",\n      }}\n    >\n      <motion.div\n        key={text}\n        initial={{ opacity: 0 }}\n        animate={\n          phase === \"fadeIn\"\n            ? { opacity: 1 }\n            : phase === \"fadeOut\"\n            ? { opacity: 0 }\n            : { opacity: 1 }\n        }\n        transition={\n          phase === \"fadeIn\"\n            ? { duration: typeDurationMs / 1000 }\n            : { duration: deleteDurationMs / 1000 }\n        }\n        onAnimationComplete={() => {\n          if (phase === \"fadeIn\") {\n            setPhase(\"hold\");\n            if (allowDelete) {\n              const t = window.setTimeout(\n                () => setPhase(\"fadeOut\"),\n                pauseAfterTypeMs\n              );\n              timers.current.push(t);\n            }\n          } else if (phase === \"fadeOut\") {\n            onDeleteComplete?.();\n          }\n        }}\n        style={{ display: \"inline-block\" }}\n      >\n        <span className=\"text-sm text-muted-foreground select-none\">\n          {text}\n        </span>\n      </motion.div>\n    </div>\n  );\n};\n\n/* ---------------------------\n   SuggestiveSearch Orchestrator\n   - handles input state, sizing/measurement of overlay bounds,\n     effect selection & cycling suggestions.\n   ----------------------------*/\nexport const SuggestiveSearch: React.FC<SuggestiveSearchProps> = ({\n  onChange,\n  suggestions = [\"Search your favourite movie\", \"Search user from connection\"],\n  className,\n  Leading = () => <Search className=\"size-4 text-muted-foreground\" />,\n  showLeading = true,\n  Trailing = () => <Search className=\"size-4 text-muted-foreground\" />,\n  showTrailing = false,\n  effect = \"typewriter\",\n  EffectComponent,\n  typeDurationMs = 500,\n  deleteDurationMs = 300,\n  pauseAfterTypeMs = 1500,\n  animateMode = \"infinite\",\n}) => {\n  const [search, setSearch] = useState<string>(\"\");\n  const [isFocused, setIsFocused] = useState(false);\n\n  const [index, setIndex] = useState<number>(0);\n  const current = useMemo(() => suggestions[index] ?? \"\", [suggestions, index]);\n\n  const wrapperRef = useRef<HTMLDivElement | null>(null);\n  const leadingRef = useRef<HTMLDivElement | null>(null);\n  const overlayRef = useRef<HTMLDivElement | null>(null);\n  const inputRef = useRef<HTMLInputElement | null>(null);\n  const trailingRef = useRef<HTMLDivElement | null>(null);\n\n  const [leftOffsetPx, setLeftOffsetPx] = useState<number | null>(null);\n  const [rightOffsetPx, setRightOffsetPx] = useState<number | null>(null);\n\n  // pixel width of the longest suggestion text (measured via canvas)\n  const [measuredLongestTextPx, setMeasuredLongestTextPx] = useState<\n    number | null\n  >(null);\n  // available width for text inside wrapper (wrapper width minus left/right offsets)\n  const [availableTextAreaPx, setAvailableTextAreaPx] = useState<number | null>(\n    null\n  );\n\n  // compute longest suggestion string\n  const longestSuggestion = useMemo(\n    () => suggestions.reduce((a, b) => (a.length > b.length ? a : b), \"\"),\n    [suggestions]\n  );\n\n  // measure paddings & leading/trailing width to compute overlay left/right & available area\n  useEffect(() => {\n    const wrapper = wrapperRef.current;\n    const lead = leadingRef.current;\n    const trail = trailingRef.current;\n    if (!wrapper) return;\n\n    const update = () => {\n      const cs = getComputedStyle(wrapper);\n      const padLeft = parseFloat(cs.paddingLeft || \"0\");\n      const padRight = parseFloat(cs.paddingRight || \"0\");\n      const leadW = showLeading ? lead?.getBoundingClientRect().width ?? 0 : 0;\n      const trailW = showTrailing\n        ? trail?.getBoundingClientRect().width ?? 0\n        : 0;\n      const left = padLeft + leadW + 8; // small gap\n      setLeftOffsetPx(left);\n      const right = padRight + trailW;\n      setRightOffsetPx(right);\n\n      const wrapperW = wrapper.getBoundingClientRect().width;\n      const avail = Math.max(0, wrapperW - left - right);\n      setAvailableTextAreaPx(avail);\n    };\n\n    update();\n    const ro = new ResizeObserver(update);\n    ro.observe(wrapper);\n    if (lead) ro.observe(lead);\n    if (trail) ro.observe(trail);\n    return () => ro.disconnect();\n  }, [showLeading, showTrailing]);\n\n  // measure pixel width of longestSuggestion using canvas with input's font\n  useEffect(() => {\n    const input = inputRef.current;\n    if (!longestSuggestion) {\n      setMeasuredLongestTextPx(null);\n      return;\n    }\n\n    const canvas = document.createElement(\"canvas\");\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) {\n      setMeasuredLongestTextPx(null);\n      return;\n    }\n\n    const elForFont = input ?? wrapperRef.current;\n    if (!elForFont) {\n      ctx.font =\n        \"14px system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial\";\n    } else {\n      const cs = getComputedStyle(elForFont);\n      const font = `${cs.fontStyle} ${cs.fontVariant} ${cs.fontWeight} ${cs.fontSize} / ${cs.lineHeight} ${cs.fontFamily}`;\n      ctx.font = font;\n    }\n\n    const metrics = ctx.measureText(longestSuggestion);\n    const measured = Math.ceil(metrics.width) + 8;\n    setMeasuredLongestTextPx(measured);\n  }, [longestSuggestion, inputRef.current]);\n\n  // choose effect component (same as before, includes new 'fade')\n  const builtinMap: Record<BuiltinEffect, React.ComponentType<any>> = {\n    typewriter: TypewriterEffect,\n    slide: SlideEffect,\n    fade: FadeEffect,\n    none: () => null,\n  };\n  const ChosenEffect = EffectComponent ?? builtinMap[effect];\n\n  const prefersReduced =\n    typeof window !== \"undefined\" &&\n    window.matchMedia &&\n    window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches;\n\n  function handleEffectDeleteComplete() {\n    setIndex((i) => (i + 1) % suggestions.length);\n  }\n\n  const handleInputChange = (val: string) => {\n    setSearch(val);\n    onChange?.(val);\n  };\n\n  // compute minWidthPx: try to use measuredLongestTextPx if available and parent has space,\n  // otherwise use availableTextAreaPx. If measurement not ready, no minWidth applied.\n  const minWidthPx =\n    measuredLongestTextPx != null && availableTextAreaPx != null\n      ? Math.min(measuredLongestTextPx, availableTextAreaPx)\n      : measuredLongestTextPx != null\n      ? measuredLongestTextPx\n      : undefined;\n\n  // overlay is active only when input empty AND not focused\n  const overlayActive = !search && !isFocused;\n\n  // compute allowDelete: in \"once\" mode, prevent deleting when on last suggestion\n  const isLast = index === suggestions.length - 1;\n  const allowDelete = animateMode === \"infinite\" ? true : !isLast;\n\n  return (\n    <div\n      ref={wrapperRef}\n      className={cn(\n        \"relative flex items-center gap-x-2 py-2 px-4 border border-border rounded-full\",\n        className\n      )}\n      style={{ maxWidth: \"100%\" }}\n    >\n      {/* Leading icon (optional) */}\n      <div ref={leadingRef} className=\"flex-shrink-0\">\n        {showLeading && <Leading />}\n      </div>\n\n      <input\n        ref={inputRef}\n        type=\"text\"\n        value={search}\n        onFocus={() => setIsFocused(true)}\n        onBlur={() => setIsFocused(false)}\n        onChange={(e) => handleInputChange(e.target.value)}\n        className=\"bg-transparent outline-none text-sm text-foreground placeholder:text-transparent w-full\"\n        placeholder=\"\"\n        aria-label=\"search\"\n        // set minWidth based on pixel measurement (if available)\n        style={\n          minWidthPx != null\n            ? { minWidth: `${minWidthPx}px` }\n            : { minWidth: undefined }\n        }\n      />\n\n      {/* Trailing icon (optional) */}\n      <div ref={trailingRef} className=\"flex-shrink-0\">\n        {showTrailing && Trailing && <Trailing />}\n      </div>\n\n      {/* overlay area: only render when input empty and not focused */}\n      {overlayActive && (\n        <div\n          ref={overlayRef}\n          aria-hidden\n          style={{\n            position: \"absolute\",\n            left:\n              leftOffsetPx != null\n                ? `${leftOffsetPx}px`\n                : \"calc(0.5rem + 1.5rem + 8px)\",\n            right: rightOffsetPx != null ? `${rightOffsetPx}px` : \"0.5rem\",\n            top: 0,\n            bottom: 0,\n            display: \"flex\",\n            alignItems: \"center\",\n            pointerEvents: \"none\",\n            overflow: \"hidden\",\n            whiteSpace: \"nowrap\",\n          }}\n        >\n          <ChosenEffect\n            text={current}\n            isActive={overlayActive}\n            allowDelete={allowDelete}\n            typeDurationMs={typeDurationMs ?? 500}\n            deleteDurationMs={deleteDurationMs ?? 300}\n            pauseAfterTypeMs={pauseAfterTypeMs ?? 1500}\n            prefersReducedMotion={prefersReduced}\n            onDeleteComplete={handleEffectDeleteComplete}\n            containerRef={overlayRef}\n          />\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default SuggestiveSearch;\n",
      "type": "registry:component",
      "target": "components/spartan-ui/SuggestiveSearch.tsx"
    },
    {
      "path": "registry/new-york/lib/utils.ts",
      "content": "import { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n",
      "type": "registry:lib",
      "target": "lib/utils.ts"
    }
  ]
}